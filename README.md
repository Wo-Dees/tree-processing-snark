# API обработки данных:

### Требования (желания):
- API должно быть асинхронным, чтобы у нас был хотя бы шанс масштабироваться по размеру входных данных.
- Вычисления должны быть ленивые, то есть в идеале, чтобы объявление какого-либо действия не
  приводило к его выполнению, интересный факт: выполнения этого требования автоматически выполнит
  первый пункт.
- Желательно добиться параллельности обработки данных.

### Что можно сделать, чтобы воплощать эти желания:
- Пункты 1 и 2 можно реализовать с помощью `Future` представления нашего дерева объектов.
  `Future` позволяют писать синхронный код, который будет сам под капотом трансформироваться
  в асинхронные исполнения. Так же `Future` и их язык комбинаторов позволят нам декларативно
  композировать асинхронных операции, которые будут исполняться лениво.
- Чтобы разобраться с параллельностью надо в начале обозначить какие операции мы ходим 
  поддерживать, а дальше уже думать как их можно распараллелить. На обсуждениях было предложенно, 
  что для начала хочется научиться поддерживать map-reduce операции, так как это позволит 
  сделать масштабировать систему в случае необходимости.

### Отправная точка:
На первом этапе пусть данные помещаются на одну машину, обработку мы тоже производим на одной машине, 
поэтому будем представлять наши данные в виде графа - графа документов. Документ - это какая-то сущность,
которая в первую очередь хранить в себе какие-то данные, вероятно, которые нужны пользователю, а так же
список документов, на которые документ, возможно, ссылается. Я вижу таким представление этой сущности в коде

```cpp
class Document {
    ...
    private:
        Information information_;
        std::deque<std::shared_ptr<Document>> links_;
}
```

```cpp
class DataGraph {
    ...
    private:
        size_t head_;
        std::vector<std::shared_ptr<Document>> documents_;
}
```
Как выше я уже оговорился для ленивой композиции наших вычислений будем использовать `Future<DataGraph>` 
представления графа данных. 

Для всей это истории у нас должна возникнуть среда исполнения - `Executor`, ориентировочно какой-нибудь 
`ThreadPool`:

```cpp
ThreadPool pool{4};
```

Вычисления над графом данных можно композировать с помощью асинхронных продолжений `Then` и языка 
комбинаторов. Пример композиции:

```cpp
DataGraph data_1;
DataGraph data_2;

auto [f_1, p_1] = futures::MakeContract<DataGraph>();
auto [f_2, p_2] = futures::MakeContract<DataGraph>();

auto future_data_1 = std::move(f_1)
  .Via(mappers).Then(f1).Then(f2).
  .Via(reducres).Then(f3);

auto future_data_2 = std::move(f_2)
  .Via(mappers).Then(f4).Then(f5).
  .Via(reducers).Then(f6);
  // лениво описали процесс вычислений
  // mappers и reducers - пулы, соответвующие своим названиям,
  // кажется в таком разделении нет необходимости, но я просто
  // хотел показать наличие такой возможности

Execute(mappers, [p = std::move(p_1), &data_1]() {
  data_1.download(...);
});
Execute(mappers, [p = std::move(p_2), &data_2]() {
  data_2.download(...);
});
// запустили вычисления, загрузив откуда-то данные

auto final_data = All(std::move(future_data_1), std::move(future_data_2));
// дальше уже как-то работаем final_data, это по сути Future<std::vector<DataGraph>>
```

Теперь более конкретно обсудим каждую функцию:
##### Map 
Я пока не буду думать о том, что я по идее щас буду обращаюсь к приватным полям, этот вопрос решим потом.
В качестве таких фунций у нас выступают f1, f2, f4, f5 на примере выше, а какое у них должно быть API?
Вообще говоря на всё поля разработчкика, главное, чтобы принимаемые и возвращаемые типы были соглосованы 
в асинхронных продолжениях, я рассмотрю простейший случай:

```cpp
DataGraph f1(DataGraph data_graph) {
    for (auto& doc : data_graph) {
        mappers.Execute([&doc](){
           f(*doc);  
           // какую-то операцию произвожу с doc, пусть оно типа принимаетмя в f по ссылке и там же изменяется 
        });
        // запланировали задачу выполнения обработки узла в каком-то текущем пуле, то есть в mappers 
    }
    return std::move(data_graph);
}
```

######  Замечание:
Эта модель будет работать только с операциями, которые не изменяют общимие данные, если такая потребность 
возникнет, а она возникнет, то можно сделать всё красивее =)

```cpp
DataGraph f1(DataGraph data_graph) {
    for (auto& doc : data_graph) {
        fibers::Go(mappers, [&doc](){
           f(*doc);  
           // какую-то операцию произвожу с doc, пусть оно типа принимаетмя в f по ссылке и там же изменяется 
        })
        // запланировал файбер на исполнение в mappers пул потоков
    }
    return std::move(data_graph);
}
```

Преимущество последнего способа в том, что у нас уже есть возможность изменять разделяемые данные,
так как у файберов есть примитивы синхронизации, более того у них есть каналы, это может нам позволить 
коммуницировать между задачами, но это возможно пока не нужно.
Однако у этого способа есть большой недостаток, мы потеряли возможность простым способом сделать
систему распределённой.

##### Reduce

У нас в задаче возникает неклассический reduce. Это даёт большую сложность для реализации обощённого reduce,
вероятно его не существует, так как он может решать слишком разные задачи. 


    # tree-processing-snark-
